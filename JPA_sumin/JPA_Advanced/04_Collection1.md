# API 개발 고급 - 컬렉션 조회 최적화 (14~17)

## 주문 조회 V1 : 엔티티를 직접 노출

## 주문 조회 V2 : 엔티티를 DTO로 변환

## 주문 조회 V3 : 엔티티를 DTO로 변환 - 페치 조인 최적화
### 페치 조인 시 특징
- 페치 조인으로 SQL이 한번만 실행됨
- distinct를 사용하는 이유는 1대다 조인이 있으므로 데이터베이스 row가 증가함. 그 결과 같은 order 엔티티의 조회 수도 증가함.
JPA의 distinct는 SQL에 distinct를 추가하고, 더해서 같은 엔티티가 조회되면, 애플리케이션에서 중복을 거름
  이 예에서 order가 컬렉션 페치 조인 때문에 중복 조회 되는 것을 막아줌
### 단점
- 페이징 불가능
> 참고
> >컬렉션 페치 조인을 사용하면 페이징 불가능. 하이버네이트는 경고 로그를 남기면서 모든 데이터를 DB에서 읽어오고, 메모리에서
>페이징 해버림.(매우 위험!)

## 주문 조회 V3.1 : JPA에서 DTO로 변환 - 페이징과 한계 돌파
### 페이징과 한계 돌파
- 컬렉션을 페치 조인하면 페이징이 불가능
    - 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가
    - 일대다에서 일(1)을 기준으로 페이징을 하는 것이 목적. 그런데 데이터는 다(N)을 기준으로 row가 생성
    - Order를 기준으로 페이징 하고 싶은데 OrderItem을 조인하면 OrderItem이 기준이 되어버림
- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도, 최악의 경우 장애로 이어짐.    
### 한계 돌파
- 대부분의 페이징 + 컬렉션 엔티티 조회 문제는 이 방법으로 해결 가능
- 먼저 ToOne 관계를 모두 페치 조인 함. ToOne 관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않음.
- 컬렉션은 지연 로딩으로 조회
- 지연 로딩 성능 최적화를 위해 'hibernate.default_batch_fetch_size', '@BatchSize'를 적용
    - hibernate.default_batch_fetch_size : 글로벌 설정
    - @BatchSize : 개별 최적화
    - 이 옵션을 사용하면 컬렉션이나 프록시 객체를 한꺼번에 설정한 size만큼 IM 쿼리로 조회함
### 장점
- 쿼리 호출 수가 1+N -> 1+1로 최적화 됨
- 조인보다 DB 데이터 전송량이 최적화 됨. (Order와 OrderItem을 조인하면 Order가 OrderItem만큼 중복해서 조회됨. 이 방법은
  각각 조회하므로 전송해야 할 중복 데이터가 없음)
- 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소함
- 컬렉션 페치 조인은 페이징이 불가능하지만 이 방법은 가능함
### 결론
- ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않음. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고,
나머지는 hibernate.default_batch_fetch_sizw로 최적화 하자. 

